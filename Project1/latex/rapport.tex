\documentclass[a4paper,11pt, english, twoside]{article}
% Engine-specific settings
% Detect pdftex/xetex/luatex, and load appropriate font packages.
% This is inspired by the approach in the iftex package.
% pdftex:
\ifx\pdfmatch\undefined
\else
    \usepackage[T1]{fontenc}
    \usepackage[utf8]{inputenc}
\fi
% xetex:
\ifx\XeTeXinterchartoks\undefined
\else
    \usepackage{fontspec}
    \defaultfontfeatures{Ligatures=TeX}
\fi
% luatex:
\ifx\directlua\undefined
\else
    \usepackage{fontspec}
\fi
% End engine-specific settings
\usepackage[english]{babel}
\usepackage{csquotes}
\usepackage[backend=biber, sortcites]{biblatex}
\usepackage{url}
\usepackage{textcomp}
\usepackage[usenames,dvipsnames,svgnames, table]{xcolor}
\usepackage[font={scriptsize}]{caption}
\usepackage{amsmath} \usepackage{amsthm} \usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{tikz} \usepackage{float}
\usepackage[procnames]{listings}
\usepackage{pstool} \usepackage{pgfplots}
\usepackage{wrapfig} \usepackage{graphicx} \usepackage{epstopdf}
\usepackage{afterpage}
\usepackage{multirow}
\usepackage{gensymb}
\usepackage{algorithm}
\usepackage{microtype}
\usepackage[noend]{algpseudocode}
\usepackage{xcolor,colortbl}
\usepackage{microtype}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{pdfpages}
\usepackage{lipsum}
\usepackage{pythontex}
\usepackage{authblk}
\floatstyle{plaintop}
\restylefloat{table}


\newcommand{\mc}[2]{\multicolumn{#1}{c}{#2}}
\definecolor{Gray}{gray}{0.90}
\definecolor{LightCyan}{rgb}{0.88,1,1}

\newcolumntype{a}{>{\columncolor{Gray}}c}
\newcolumntype{b}{>{\columncolor{white}}c}
\definecolor{tablecolor}{gray}{0.95}
\definecolor{tabletext}{gray}{0.0}
\definecolor{tablerule}{gray}{0.7}
\definecolor{titlepagecolor}{cmyk}{1,.60,0,.40}
\definecolor{namecolor}{cmyk}{1,.50,0,.10}

% Custom commands
\newcommand{\unit}[1]{\:\mathrm{#1}}
\newcommand{\noref}[1]{\hyperref[#1]{\ref*{#1}}}
\newcommand{\nonref}[1]{\hyperref[]{\ref*{#1}}}
\newcommand\blankpage{%
  \null
  \thispagestyle{empty}%
  \addtocounter{page}{-1}%
  \newpage}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{7} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{7}  % for normal

\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

\title{Project 1}

% Biber for references
\addbibresource{references.bib}

\begin{document}
\author[1]{Erlend Lima}
\author[2]{Frederik J. Mellbye}
\author[3]{Aram Salihi}
\author[4]{Halvard Sutterud}
\affil[1,2,3,4]{University of Oslo, Oslo, Norway}
\maketitle

\begin{abstract}
  In this project three methods of solving the one-dimensional Poisson equation with
  Dirchelet boundary conditions are investigated. The equation was discretized,
  and written as a system of linear equations. This equates to
  a tridiagonal matrix equation, which was solved using the general Thomas algorithm,
  a specialized version of the Thomas algorithm and by LU-decomposing the matrix. The
  numerical error is then analyzed for both methods, and the algorithm speeds are investigated and discussed.

  The specialization of the algorithm for our specific problem resulted in
  a x percent reduction in the amount of floating point operations. For large
  matrices ($n \sim 10^5$) the LU-decomposition requires
  more memory than what was available, which was not a problem with the Thomas
  algorithm. Also, the Thomas algorithm produced solutions with smaller errors
  than the LU method. Therefore the Thomas is deemed most suited for solving the problem
  examined in this paper.
\end{abstract}

% Get all of the data from the script into a dictionary
\begin{pycode}
from subprocess import Popen, PIPE
from latextools import untag_all
p = Popen(['python', '../analysis/analyze.py', '../cpp'],
stdout=PIPE, stderr=PIPE)
output, err = p.communicate()
data = output.decode('utf8')
latex_data = untag_all(data)
\end{pycode}

\begin{table}[ht]
  \centering
  \pyc{print(latex_data['error_table'])}
  \caption{Summary of the errors}
  \label{tab:error}
\end{table}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.5]{figures/function.eps}
  \caption{\label{fig:general} Caption}
\end{figure}

\section{Introduction}
Introducing where the Poisson equation comes from, why it valuable to solve it,
how it is solved in this paper and explaining speed and error analysis.

\section{Theory}
\subsection{Discretizing the Poisson equation}
The one-dimensional Poisson equation with Dirchelet boundary conditions is
\begin{align*}
  \frac{d^2 u}{d x^2} = - f
\end{align*}
We can approximate the second derivative of $u(x)$ using a Taylor expansion
and solving for $\frac{d^2 u}{d x^2}$:
\begin{align*}
  \frac{d^2 u}{d x^2} \approx \frac{u(x+h) + u(x-h) - 2 u(x)}{h^2} + O(h^2)
\end{align*}
The equation is discretized with grid points $x_1, x_2, \hdots, x_{n}$. Imposing
Dirchelet boundary conditions forces $x_1 = x_n = 0$, using the handy notation
$u(x_i + h) = u_{i+1}$ and inserting the approximated second derivative into the
Poisson equation yields
\begin{align*}
  \frac{u_{i+1} + u_{i-1} - 2 u_i}{h^2} = -f_i
\end{align*}
where $h = \frac{1}{n+1}$ is the step size, i.e. the distance between grid points, and
$f_i = f(x_i)$. This discretized version of the one dimensional Poisson equation is
conveniently a linear system of equations, and can therefore be written
as the matrix equation
\begin{align*}
  A \mathbf{u} = h^2 \mathbf{f}
\end{align*}
where
\begin{align*}
  A =
  \begin{bmatrix}
    2 & -1 & 0  & \hdots & \hdots &   0    \\
    -1 & 2 & -1 & 0      & &\vdots \\
    0 & -1 & 2  & -1     & 0 &  \\
    \vdots & 0 & -1  & 2     & -1 & 0 \\
    & & \ddots & \ddots & \ddots & \vdots\\
    0 & \hdots  &\hdots & 0 &-1 & 2 \\
\end{bmatrix}
\end{align*}
is a $n \times n$ tridiagonal matrix, the only non-zero elements are on,
directly above or directly below the diagonal. Row reducing the matrix can therefore
be done in an efficient way using the Thomas algorithm, as we shall see in the next paragraph.
\subsection{Solving a general tridiagonal matrix problem}
A general tridiagonal matrix equation is on the form
\begin{align*}
  \begin{bmatrix}
    b_1 & c_1 & 0  & \hdots & \hdots &   0    \\
    a_2 & b_2 & c_2 & 0      & &\vdots \\
    0 & a_3 & b_3  & c_3     & 0 &  \\
    \vdots & 0 & a_4  & b_4     & c_4 & 0 \\
    & & \ddots & \ddots & \ddots & \vdots\\
    0 & \hdots  &\hdots & 0 &a_n & b_n \\
  \end{bmatrix}
  \begin{bmatrix}
    u_1 \\ u_2 \\ u_3 \\ \vdots \\ \\ u_n
  \end{bmatrix}
  =
  \begin{bmatrix}
    v_1 \\ v_2 \\ v_3 \\ \vdots \\ \\ v_n
  \end{bmatrix}
\end{align*}
where $v_i = h^2 f_i$ in the case examined in this project. To get the matrix
in row reduced echelon form and solve the problem, the $a_i$'s are first eliminated
by Gaussian elimination.
First, $\frac{a_2}{b_1}$ times the first row is subtracted from the second.
This gives
\begin{align*}
  \begin{bmatrix}
    b_1 & c_1 & 0  & \hdots & \hdots &   0    \\
    0 & b'_2 & c_2 & 0      & &\vdots \\
    0 & a_3 & b_3  & c_3     & 0 &  \\
    \vdots & 0 & a_4  & b_4     & c_4 & 0 \\
    & & \ddots & \ddots & \ddots & \vdots\\
    0 & \hdots  &\hdots & 0 &a_n & b_n \\
  \end{bmatrix}
  \begin{bmatrix}
    u_1 \\ u_2 \\ u_3 \\ \vdots \\ \\ u_n
  \end{bmatrix}
  =
  \begin{bmatrix}
    v_1 \\ v'_2 \\ v_3 \\ \vdots \\ \\ v_n
  \end{bmatrix}
\end{align*}
where $b'_2 = b_2 - \frac{a_2}{b_1} c_1$ and $v'_2 = v_2 - \frac{a_2}{b_1}v_1$.
For the next row, exactly the same operation is used, but notice how the previous
elements $b'_2$ and $v'_2$ now have been updated in the last iteration. Generalizing this
argument for each row, a general expression for the diagonal elements is
\begin{align*}
  b'_i = b_i - \frac{a_i}{b'_{i-1}}c_{i-1}
\end{align*}
where $b'_1 = b_1$ and $i = 2,3,...,n$. Similarly, elements in the right-hand side vector
$\mathbf{v}'$ are modified to
\begin{align*}
  v'_{i} = v_i - \frac{a_i}{b'_{i-1}}v_{i-1}
\end{align*}
where $v'_1 = v_1$ and $i = 2,\hdots,n$. After completing the forward substitution,
the matrix equation reads
\begin{align*}
  \begin{bmatrix}
    b'_1 & c_1 & 0  & \hdots & \hdots &   0    \\
    0 & b'_2 & c_2 & 0      & &\vdots \\
    0 & 0 & b'_3  & c_3     & 0 &  \\
    \vdots & 0 & 0  & b'_4     & c_4 & 0 \\
    & & \ddots & \ddots & \ddots & \vdots\\
    0 & \hdots  &\hdots & 0 &0 & b'_n \\
  \end{bmatrix}
  \begin{bmatrix}
    u_1 \\ u_2 \\ u_3 \\ \vdots \\ \\ u_n
  \end{bmatrix}
  =
  \begin{bmatrix}
    v'_1 \\ v'_2 \\ v'_3 \\ \vdots \\ \\ v'_n
  \end{bmatrix}
\end{align*}
By inspection, the solution for the final point $u_n$ is explicitly given by the
bottom row:
\begin{align*}
  b'_n u_n = v'_n \rightarrow u_n = \frac{v'_n}{b'_n}
\end{align*}
The rest of the solution $u(x_i)$ is then computed by backward substitution, given
$u_i$ one can compute $u_{i-1}$. For instance, row $n-1$ reads
\begin{align*}
  b'_{n-1} u_{n-1} + c_{n-1} u_n &= v'_{n-1} \\
  u_{n-1} &= \frac{v'_{n-1} - c_{n-1} u_n}{b'_{n-1}}
\end{align*}
In general then, the back substitution is done by
\begin{align*}
  u_i = \frac{v'_i - c_i u_{i+1}}{b'_i}
\end{align*}
where $i = n-1, n-2, \hdots, 1$.
\subsection{Optimizing the Thomas algorithm for a specific case}
In the case presented in this project, $a_i = c_i = -1$ and $b_i = 2$. The fact
that there are just two different values in the matrix greatly simplifies the
calculations, since all the calculations involving only $a_i$, $b_i$ and $c_i$
can be done beforehand. Also, it is possible to derive an analytic expression for
$b'_i$. This is given by
\begin{align*}
  b'_i =
\end{align*}
and is found and proved by induction in appendix A?.
\subsection{Solving the general tridiagonal matrix problem by LU-decomposition}
Another way to solve matrix equations is LU-decomposing A, and then solving
two matrix equations. This is a frequently used method for solving more general
sets of linear equations. The LU-decomposition is a form of Gaussian elimination,
where A is factored into matrices L and U. L is lower triangular with 1 in each
element on the diagonal, and U is upper triangular. The matrix equation is
\begin{align*}
  A\mathbf{u} &= \mathbf{v} \\
  LU \mathbf{u} &= \mathbf{v}
\end{align*}
Introducing $\mathbf{y} = U\mathbf{u}$, the solution $\mathbf{u}$ can now be
computed in two steps. First, $\mathbf{y}$ is found by solving
\begin{align*}
  L\mathbf{y} = \mathbf{v}
\end{align*}
which is then inserted in LABEL
\begin{align*}
  U\mathbf{u} = \mathbf{y}
\end{align*}
and solved for $\mathbf{u}$.
\subsection{Analytic solution for a specific problem}
In this paper the following special case of the Poisson equation is examined:
\begin{align}
  - \frac{d^2 u}{dx^2} = 100 e^{-10x}
\end{align}
where $0 < x < 1$ and $u(0) = u(1) = 0$, i.e. Dirchelet boundaries. An analytic
solution is obtained by integrating with respect to $x$ twice
\begin{align*}
  u(x) = -e^{-10x} + A + Bx
\end{align*}
Imposing the boundary condition $x(0) = 0$ gives $u(0) = 0 = -1 + A$, so
$A = 1$. Applying $x(1) = 0$ gives $0 = -e^{-10} + 1 + B$, so $B = e^{-10} - 1$.
Inserting the integration constants returns the analytical solution
\begin{align}
  u(x) = 1 - (1 - e^{-10})x - e^{-10x}
\end{align}
where $0 < x < 1$ and $u(0) = u(1) = 0$.

\section{Method}
The algorithms were implemented in C++, Julia and Fortran, with the purpose of
learning multiple programming languages and verifying the correctness of the implementations.
The source code is available in the attatched GIT-repository. The calculations
were performed several times, and for each method the algorithm times were averaged to produce a
mean time. The implementations are explained and listed in the following sections with pseudocode.

\subsection{The general Thomas algorithm}
Pseudocode.
\subsection{The tailored algorithm}
Pseudocode.
\subsection{The LU-decomposition}
Armadillo functions lu and solve.
\subsection{Error analysis}
\begin{align*}
  \epsilon_i = \text{log}_{10} \left( \left| \frac{v_i - u_i}{u_i} \right| \right)
\end{align*}
where $v_i$ is the numerically calculated value at $x_i$, and $u_i$ is the analytic value.
\section{Results and discussion}
\subsection{Solution using the algorithms}
Plot osv.
\subsection{Error and error analysis}
Plot av feil for mange $n$.
\subsection{Timing the algorithms}
Tabell med hastigheter. kjÃ¸r mange ganger, ta avg.

\section{Conclusion}

\section{References}

\section{Appendix}
\subsection{Deriving a general expression for the diagonal elements after forward substituting}
The general expression for the diagonal elements in $A$ after forward substituting was
\begin{align*}
  b'_i = b_i - \frac{a_i}{b'_{i-1} c_i}
\end{align*}
for $i = 2, \hdots, n$. Since $a_i = c_i$ for all $i$ in the special case examined in this paper,
 the expression for $b'_i$ simplifies to
\begin{align*}
  b'_i = b_i - \frac{1}{b'_{i-1}}
\end{align*}
In an attempt at further simplify the expression, a few iterations are calculated, and
a pattern seems to emerge:
\begin{align*}
  b'_1 &= b_1 = 2\\
  b'_2 &= b_2 - \frac{1}{b'_1} = 2 - \frac{1}{2} = \frac{3}{2}\\
  b'_3 &= b_3 - \frac{1}{b'_2} = 2 - \frac{2}{3} = \frac{4}{3}\\
  b'_4 &= b_4 - \frac{1}{b'_3} = 2 - \frac{3}{4} = \frac{5}{4}
\end{align*}
By inspection, $b'_i$ seems to follow the pattern
\begin{align*}
  b'_i &= \frac{i+1}{i}
\end{align*}
which is assumed valid for $i = 1,2,\hdots,n$. A proof by induction is used to
show that the formula is indeed correct for all $i \geq 1$.
\\[12pt]
For any integer $i \geq 1$, let $S(i)$ denote the statement
\begin{align*}
  S(i): b'_i = 2 - \frac{1}{b'_{i-1}} = \frac{i+1}{i}
\end{align*}
where we have defined $b'_{1} = 2$.

$S(1)$ says $b_1 = 2 - \frac{1}{b'_{i-1}} = 2$, which is correct by the simple fact that $b'_1 = b_i = 2$.

For some fixed $j \geq
\end{document}
